import json
import datetime
import sys
from pymongo import MongoClient, errors

# Class implemented to do mongodb-related functions
# Still contains useless functions that will be removed
class database_handler(object): 
    # Initialization of database connection
    def __init__(self, ip, port):
        self.mongoclient = MongoClient(ip, port)
        self.category_db = self.mongoclient.category

    # Returns all data in a collection 
    def return_collection(self, collection):
        return [items for items in collection.find({})]

    # Clears an entire collection and prints the ammount of objects removed
    def clear_collection(self, collection):
        cnt = 0

        for item in collection.find({}):
            collection.remove(item)
            cnt += 1

        if cnt > 0:
            print "Cleared %d elements in the collection" % cnt
        else:
            print "Nothing to clear."

    # Removes a single datapoint based on the datareference. 
    def remove_one(self, collection, id):
        data = collection.find_one({'_id': id})

        if data is not None:
            collection.remove({'_id': id})

    # Returns avilable docs in a collection
    def get_available_category_collections(self):
        category_collection = self.category_db.collection_names(include_system_collections=False)
        return category_collection

    # Adds data to a category and returns the ID generated by MongoDB
    def add_new_category_data(self, database, category, name, cur_time, ip="", url="", hash=""):
        collection = database[category]

        if collection.find({"name": name}).count() > 0:
            category_data = collection.find_one({"name": name})

            # Might want to append ObjectID instead of IP? idk :)
            # Append appropriate data to list
            if ip and ip not in category_data["ips"]:	
                category_data["ips"].append(ip)
            if url and url not in category_data["urls"]:
                category_data["urls"].append(url)
            if filehash and filehash not in category_data["filehash"]:	
                category_data["filehash"].append(filehash)

            category_data["modifieddate"] = cur_time
            collection.save(category_data)
            return category_data["_id"]
        else:
            # To create a new object
            category_data = {
                "name": name,
                "ips": [],
                "urls": [],
                "filehash": [],
                "addeddate": cur_time,
                "modifieddate": cur_time
            }

            if ip:
                category_data["ips"].append(ip)
            if url:
                category_data["urls"].append(url)
            if filehash:
                category_data["filehash"].append(filehash)

            return_id = collection.insert_one(category_data).inserted_id
            return return_id

    # Finds the IP collection
    def evaluate_collection(self, data_type, item):
        if data_type == "ip":
            type_collection = ""
            for dot_value in range(len(item)):
                if item[dot_value] == ".":
                    collection = item[:dot_value]
                    if int(collection) < 256 and int(collection) > -1:
                        return collection
        else:
            return item[:2]

    # Now able to handle bulk input
    def add_data_new(self, database, data_type, item, category, name, extra_data={}, **kwargs):
        """ 
            database - Which database to use
            category_db - Who was the sender? What kind of information?
            data_type - ip, url, hash
            item - actual data
            category - what category (malware, scanning etc)
            name - name of the service that it was recieved from
        """
        cur_time = datetime.datetime.now()

        # Should be able to add multiple new items at the same time
        not_found_list = []
        if not isinstance(item, list):
            tmp_item = item
            item = [tmp_item]

        for data in item:
            type_collection = database[self.evaluate_collection(data_type, data)]
            tmp_data = type_collection.find_one({data_type: data})
            if not tmp_data:
                type_data = {
                    data_type: data,
                    "containers": [],
                    "addeddate": "%s" % cur_time,
                    "modifieddate": "%s" % cur_time
                }

                category_data = {
                    "name": name,
                    "category": category,
                    "addeddate": cur_time,
                    "modifieddate": cur_time
                }
                
                if extra_data:
                    category_data["comment"] = extra_data 

                print "Created document for %s in %s" % (data, type_collection)
                type_data["containers"].append(category_data)
                type_collection.insert_one(type_data).inserted_id

            else:
                containers = tmp_data["containers"]

                exists_check = False
                for container in containers:
                    if container["name"] == name and container["category"] == category:
                        container["modifieddate"] == cur_time
                        container["comment"] = extra_data
                        exists_check = True


                if not exists_check:
                    category_data = {
                        "name": name,
                        "category": category,
                        "addeddate": cur_time,
                        "modifieddate": cur_time
                    }

                    if extra_data:
                        category_data["comment"] = extra_data

                    tmp_data["categories"].append(category_data)

                print "Updated document for %s" % data
                type_collection.save(tmp_data)

    def find_category_object(self, collection, id):
        data = collection.find_one({"_id": id})
        # Finds the database that should be used
                
    # Can get type from collection.
    def add_data(self, database, type_collection, category_db, type, item, category="", name=""):
        object_exists = False

        # Creates category data.
        category_id = ""
        cur_time = datetime.datetime.now()

        if category and name:
            if type == "ip":
                category_id = self.add_new_category_data(category_db, \
                    category, name, cur_time, ip=item) 
            elif type == "url":
                category_id = self.add_new_category_data(category_db, \
                    category, name, cur_time, url=item) 
            elif type == "hash": 
                category_id = self.add_new_category_data(category_db, \
                    category, name, cur_time, filehash=item) 

        # Item already exists.
        if type_collection.find({type: item}).count() > 0:
            tmp_data = type_collection.find_one({type: item})
            # Verify data in containers

            category_exists = False
            for item in tmp_data["containers"]:
                if item["name"] == name and item["category"] == category:
                    category_exists = True
                    break

            # append
            if not category_exists:
                tmp_data["containers"].append({"name": name, \
                    "category": category, "mongo_id": category_id, "addeddate": cur_time})
                tmp_data["modifieddate"] = cur_time
                type_collection.save(tmp_data)

        # Return otherwise - might want to modify date of category if category/name exists?

        else:
            # Base information to add to a colleciton
            tmp_data = {
                type: "%s" % item,
                "containers": [],
                "addeddate": "%s" % cur_time,
                "modifieddate": "%s" % cur_time
            }

            # DNS stuff
            if type == "url":
                tmp_data["ip"] = [] 

        
        if category_id:
            tmp_data["containers"].append({"name": name, \
                "category": category, "mongo_id": category_id, "addeddate": cur_time})

        # Verifies duplicates, so I don't actually have to.
        try:
            return type_collection.insert_one(tmp_data).inserted_id
        except errors.DuplicateKeyError:
            return False

    def find_category_object(self, collection, id):
        data = collection.find_one({"_id": id})
        return data

    def find_category_data(self, collection, name):
        for item in collection.find({}):
            if item["name"] == name:
                return item

        return False

    # FIX - Hardcoded IP
    # Find basic
    def find_object_new(self, data_type, item):
        db = self.database.mongoclient[data_type]
        collection = db[self.evaluate_collection(data_type, item)]

        return collection.find_one({data_type: item})

    def find_category_object(self, collection, id):
        data = collection.find_one({"_id": id})
        # Finds the database that should be used
                
        #data = type_collection.find({data_type: item})
        #print data.count()

        
    # Use kwargs in case. Comment is good :) 
        
    def find_category_object(self, collection, id):
        data = collection.find_one({"_id": id})
        return data

    def find_category_data(self, collection, name):
        for item in collection.find({}):
            if item["name"] == name:
                return item

        return False

    # Finds a single p in a collection - make generic
    def find_object(self, collection, type, name):
        ## FIX - Might break because of first part of list. Need all of them concated.
        if not name:
            return [x for x in collection.find({})]

        return collection.find_one({type: name})

    # Made to test lists - Needs to contain category and stuff
    def get_data(self):
        return open("blocklist.php", "r").readlines()

    # Clears the available databases 
    def clear_all_databases(self):
        data = self.mongoclient.database_names()
        for items in data:
            self.mongoclient.drop_database(self.mongoclient[items])	
            print "Dropped %s" % items

if __name__ == "__main__":
    mongodbserver = '127.0.0.1'
    mongodbport = 27017
    print "Connecting to mongodb at %s:%d" % (mongodbserver, mongodbport)

    client = database_handler(mongodbserver, mongodbport)
    try:
        if sys.argv[1] == "clear":
            client.clear_all_databases()
            exit()
    except IndexError:
        print "Did you mean to use the argument \"clear\" or run handle_data.py?"
        exit()
    
